{"version":3,"sources":["../src/app.ts","../src/utils/utils.ts","../src/schemas/encryptionOptions.schema.ts"],"sourcesContent":["import { createCipheriv, randomBytes, scryptSync, createDecipheriv } from 'crypto';\nimport { type IEncryptionReturn, CryptographyOptions } from '@/types';\nimport { isValidPayload } from '@/utils';\nimport { CryptographyOptionsSchema } from '@/schemas/encryptionOptions.schema';\n\n/**\n * Encrypts a given payload using the provided encryption or the default is 'AES-256-CBC'.\n * @param {string} payload - The string to be encrypted.\n * @returns {object} An object containing the encrypted value and initialization vector (iv).\n */\n\nexport function encrypt(payload: string, options: CryptographyOptions): IEncryptionReturn {\n\ttry {\n\t\tconst isValid = isValidPayload(CryptographyOptionsSchema, options);\n\t\tif (!isValid.success) throw new Error('There was an error on the arguments');\n\n\t\tconst algorithm = options.algorithm || 'aes-256-cbc';\n\t\tconst encodingInput = options.encodingInput || 'utf8';\n\t\tconst encodingOutput = options.encodingOutput || 'hex';\n\t\tconst keyLength = options.keyLength || 32; // Default key length for AES-256\n\t\tconst ivSize = options.ivSize || 16;\n\n\t\tconst key = scryptSync(options.password, options.salt, keyLength);\n\t\tconst iv = randomBytes(ivSize);\n\n\t\tconst cipher = createCipheriv(algorithm, key, iv);\n\t\tlet encrypted = cipher.update(payload, encodingInput, encodingOutput);\n\t\tencrypted += cipher.final(encodingOutput);\n\n\t\treturn {\n\t\t\tmessage: 'Encrypted successfully',\n\t\t\tiv: iv.toString(encodingOutput),\n\t\t\tvalue: encrypted,\n\t\t};\n\t} catch (err) {\n\t\tconst message = err instanceof Error ? `Error encrypting data ${err.message}` : 'Unknown error';\n\t\tconsole.error(message);\n\t\tthrow new Error(message);\n\t}\n}\n\nexport function decrypt(payload: string, iv: string, options: CryptographyOptions) {\n\ttry {\n\t\t// Validation\n\t\tconst isValid = isValidPayload(CryptographyOptionsSchema, options);\n\t\tif (!isValid.success) throw new Error('There was an error on the arguments');\n\n\t\tconst algorithm = options.algorithm || 'aes-256-cbc';\n\t\tconst password = options.password;\n\t\tconst salt = options.salt;\n\t\tconst keyLength = options.keyLength || 32;\n\t\tconst encodingInput = options.encodingInput || 'hex';\n\t\tconst encodingOutput = options.encodingOutput || 'utf8';\n\n\t\tconst key = scryptSync(password, salt, keyLength);\n\t\tconst bufferedIv = Buffer.from(iv, encodingInput);\n\n\t\tconst decipher = createDecipheriv(algorithm, key, bufferedIv);\n\t\tlet decrypted = decipher.update(payload, encodingInput, encodingOutput);\n\t\tdecrypted += decipher.final(encodingOutput);\n\n\t\treturn decrypted;\n\t} catch (err) {\n\t\tconst message =\n\t\t\terr instanceof Error\n\t\t\t\t? `Error decrypting data. Check the salt or password: ${err.message}`\n\t\t\t\t: 'Unknown error';\n\t\tconsole.error(message);\n\t\tthrow new Error(message);\n\t}\n}\n","import { ZodType } from 'zod';\n\nconst isValidPayload = <T>(schema: ZodType<T>, payload: any) => {\n\tconst result = schema.safeParse(payload);\n\n\tif (!result.success) {\n\t\tconst errorObj = {\n\t\t\tsuccess: result.success,\n\t\t\terrors: result.error.issues.map((el) => {\n\t\t\t\treturn {\n\t\t\t\t\tmessage: el.message,\n\t\t\t\t\tpath: el.path,\n\t\t\t\t};\n\t\t\t}),\n\t\t};\n\t\tconsole.dir(errorObj, { depth: null });\n\t\treturn errorObj;\n\t}\n\tconsole.log('result', result);\n\treturn { success: result.success, data: result.data };\n};\n\nexport { isValidPayload };\n","import z from 'zod';\n\nconst BaseCryptographyOptions = z.object({\n\talgorithm: z.string().trim().optional(),\n\tpassword: z.string().trim().nonempty('Password is required').min(24, 'Password must be minimum of 24 characters'),\n\tsalt: z.string().trim().nonempty('salt is required').min(16, 'salt must be minimum of 16 characters'),\n\tkeyLength: z.number().optional(),\n\tivSize: z.number().optional(),\n});\n\n// Encryption options schema\nconst EncryptionOptions = BaseCryptographyOptions.extend({\n\ttype: z.literal('encryption'),\n\tencodingInput: z.literal('utf8').optional(),\n\tencodingOutput: z.enum(['hex', 'base64']).optional(),\n});\n\n// Decryption options schema\nconst DecryptionOptions = BaseCryptographyOptions.extend({\n\ttype: z.literal('decryption'),\n\tencodingInput: z.enum(['hex', 'base64']).optional(),\n\tencodingOutput: z.literal('utf8').optional(),\n});\n\n// Discriminated union\nconst CryptographyOptionsSchema = z.discriminatedUnion('type', [EncryptionOptions, DecryptionOptions]);\n\nexport { CryptographyOptionsSchema };\n"],"mappings":"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","names":["z"]}