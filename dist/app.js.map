{"version":3,"sources":["../src/app.ts","../src/utils/utils.ts","../src/schemas/encryptionOptions.schema.ts"],"sourcesContent":["import { createCipheriv, randomBytes, scryptSync, createDecipheriv } from 'crypto';\nimport { type IEncryptionReturn, CryptographyOptions } from '@/types';\nimport { isValidPayload } from '@/utils';\nimport { CryptographyOptionsSchema } from '@/schemas/encryptionOptions.schema';\n\n/**\n * Encrypts a given payload using the provided encryption or the default is 'AES-256-CBC'.\n * @param {string} payload - The string to be encrypted.\n * @returns {object} An object containing the encrypted value and initialization vector (iv).\n */\n\nexport function encrypt(payload: string, options: CryptographyOptions): IEncryptionReturn {\n\ttry {\n\t\tconst isValid = isValidPayload(CryptographyOptionsSchema, options);\n\t\tif (!isValid.success) throw new Error('There was an error on the arguments');\n\n\t\tconst algorithm = options.algorithm || 'aes-256-cbc';\n\t\tconst encodingInput = options.encodingInput || 'utf8';\n\t\tconst encodingOutput = options.encodingOutput || 'hex';\n\t\tconst keyLength = options.keyLength || 32; // Default key length for AES-256\n\t\tconst ivSize = options.ivSize || 16;\n\n\t\tconst key = scryptSync(options.password, options.salt, keyLength);\n\t\tconst iv = randomBytes(ivSize);\n\n\t\tconst cipher = createCipheriv(algorithm, key, iv);\n\t\tlet encrypted = cipher.update(payload, encodingInput, encodingOutput);\n\t\tencrypted += cipher.final(encodingOutput);\n\n\t\treturn {\n\t\t\tmessage: 'Encrypted successfully',\n\t\t\tiv: iv.toString(encodingOutput),\n\t\t\tvalue: encrypted,\n\t\t};\n\t} catch (err) {\n\t\tconst message = err instanceof Error ? `Error encrypting data ${err.message}` : 'Unknown error';\n\t\tconsole.error(message);\n\t\tthrow new Error(message);\n\t}\n}\n\nexport function decrypt(payload: string, iv: string, options: CryptographyOptions) {\n\ttry {\n\t\t// Validation\n\t\tconst isValid = isValidPayload(CryptographyOptionsSchema, options);\n\t\tif (!isValid.success) throw new Error('There was an error on the arguments');\n\n\t\tconst algorithm = options.algorithm || 'aes-256-cbc';\n\t\tconst password = options.password;\n\t\tconst salt = options.salt;\n\t\tconst keyLength = options.keyLength || 32;\n\t\tconst encodingInput = options.encodingInput || 'hex';\n\t\tconst encodingOutput = options.encodingOutput || 'utf8';\n\n\t\tconst key = scryptSync(password, salt, keyLength);\n\t\tconst bufferedIv = Buffer.from(iv, encodingInput);\n\n\t\tconst decipher = createDecipheriv(algorithm, key, bufferedIv);\n\t\tlet decrypted = decipher.update(payload, encodingInput, encodingOutput);\n\t\tdecrypted += decipher.final(encodingOutput);\n\n\t\treturn decrypted;\n\t} catch (err) {\n\t\tconst message =\n\t\t\terr instanceof Error\n\t\t\t\t? `Error decrypting data. Check the salt or password: ${err.message}`\n\t\t\t\t: 'Unknown error';\n\t\tconsole.error(message);\n\t\tthrow new Error(message);\n\t}\n}\n","import { ZodType } from 'zod';\n\nconst isValidPayload = <T>(schema: ZodType<T>, payload: any) => {\n\tconst result = schema.safeParse(payload);\n\n\tif (!result.success) {\n\t\tconst errorObj = {\n\t\t\tsuccess: result.success,\n\t\t\terrors: result.error.issues.map((el) => {\n\t\t\t\treturn {\n\t\t\t\t\tmessage: el.message,\n\t\t\t\t\tpath: el.path,\n\t\t\t\t};\n\t\t\t}),\n\t\t};\n\t\tconsole.dir(errorObj, { depth: null });\n\t\treturn errorObj;\n\t}\n\tconsole.log('result', result);\n\treturn { success: result.success, data: result.data };\n};\n\nexport { isValidPayload };\n","import z from 'zod';\n\nconst BaseCryptographyOptions = z.object({\n\talgorithm: z.string().trim().optional(),\n\tpassword: z.string().trim().nonempty('Password is required').min(24, 'Password must be minimum of 24 characters'),\n\tsalt: z.string().trim().nonempty('salt is required').min(16, 'salt must be minimum of 16 characters'),\n\tkeyLength: z.number().optional(),\n\tivSize: z.number().optional(),\n});\n\n// Encryption options schema\nconst EncryptionOptions = BaseCryptographyOptions.extend({\n\ttype: z.literal('encryption'),\n\tencodingInput: z.literal('utf8').optional(),\n\tencodingOutput: z.enum(['hex', 'base64']).optional(),\n});\n\n// Decryption options schema\nconst DecryptionOptions = BaseCryptographyOptions.extend({\n\ttype: z.literal('decryption'),\n\tencodingInput: z.enum(['hex', 'base64']).optional(),\n\tencodingOutput: z.literal('utf8').optional(),\n});\n\n// Discriminated union\nconst CryptographyOptionsSchema = z.discriminatedUnion('type', [EncryptionOptions, DecryptionOptions]);\n\nexport { CryptographyOptionsSchema };\n"],"mappings":"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","names":["app_exports","__export","decrypt","encrypt","__toCommonJS","import_crypto","isValidPayload","schema","payload","result","errorObj","el","import_zod","BaseCryptographyOptions","z","EncryptionOptions","DecryptionOptions","CryptographyOptionsSchema","encrypt","payload","options","isValidPayload","CryptographyOptionsSchema","algorithm","encodingInput","encodingOutput","keyLength","ivSize","key","iv","cipher","encrypted","err","message","decrypt","password","salt","bufferedIv","decipher","decrypted"]}